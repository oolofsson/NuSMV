MODULE semaphore(active, pid)
VAR
  state0 : { idle, entering, critical, exiting }; -- keep track of state for each process
  state1 : { idle, entering, critical, exiting };
  nextCritical : boolean; -- which process can enter into the critical section next
ASSIGN
  init(state0) := idle;
  init(state1) := idle;
  next(state0) := case
  /--
  In the critical sections we only enter if it is our turn to enter the critical section.
  The nextCritical variable is changed if one thread is in the critical section and
  the other wants to enter it, then the nextCritical variable is changed to the 
  other thread and the thread that is currently in the critical section can not
  enter it until the other thread has finished working in the critical section
  --/
    !active : state0;
    pid != 0: state0;
    state0 = idle : { idle, entering };
    state0 = entering & state1 != critical & nextCritical = FALSE: critical;
    state0 = critical : { critical, exiting };
    state0 = exiting : idle;
    TRUE : state0;
  esac;
  next(state1) := case
    !active : state1;
    pid != 1: state1;
    state1 = idle : { idle, entering };
    state1 = entering & state0 != critical & nextCritical = TRUE: critical;
    state1 = critical : { critical, exiting };
    state1 = exiting : idle;
    TRUE : state1;
  esac;
  next(nextCritical) := case
    state1 = entering & state0 = idle: TRUE;
    state0 = entering & state1 = idle: FALSE;
    state1 = critical & state0 = entering: FALSE;
    state0 = critical & state1 = entering: TRUE;
    TRUE: nextCritical;
  esac;
SPEC AG !(state0 = critical & state1 = critical); -- safety

SPEC AG (state1 = entering -> AF state1 = critical); -- liveness
SPEC AG (state0 = entering -> AF state0 = critical); -- liveness


MODULE user(semaphore, running, pid)
VAR
  sem: semaphore(running, pid);

MODULE main
VAR
  running: 0..1;
  proc1 : user(semaphore, next(running) = 0, 0);
  proc2 : user(semaphore, next(running) = 1, 1);
-- FAIRNESS
--    running = 0
-- FAIRNESS
--    running = 1
/--

-- specification AG !(state0 = critical & state1 = critical) IN proc1.sem is true
-- specification AG (state1 = entering -> AF state1 = critical) IN proc1.sem is true
-- specification AG (state0 = entering -> AF state0 = critical) IN proc1.sem is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 1.1 <-
running = 0
proc1.sem.state0 = idle
proc1.sem.state1 = idle
proc1.sem.nextCritical = FALSE
proc2.sem.state0 = idle
proc2.sem.state1 = idle
proc2.sem.nextCritical = FALSE
-> State: 1.2 <-
proc1.sem.state0 = entering
-- Loop starts here
-> State: 1.3 <-
running = 1
-> State: 1.4 <-
-- specification AG !(state0 = critical & state1 = critical) IN proc2.sem is true
-- specification AG (state1 = entering -> AF state1 = critical) IN proc2.sem is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample
-> State: 2.1 <-
running = 0
proc1.sem.state0 = idle
proc1.sem.state1 = idle
proc1.sem.nextCritical = FALSE
proc2.sem.state0 = idle
proc2.sem.state1 = idle
proc2.sem.nextCritical = FALSE
-> State: 2.2 <-
running = 1
proc2.sem.state1 = entering
-> State: 2.3 <-
proc2.sem.nextCritical = TRUE
-- Loop starts here
-> State: 2.4 <-
running = 0
-> State: 2.5 <-
-- specification AG (state0 = entering -> AF state0 = critical) IN proc2.sem is true
--/
/--
In this stack trace the process with pid 0 is always running so process with pid 1
can never enter the critical section
--/
