MODULE user(semaphore, active)
VAR
  state : { idle, entering, critical, exiting };
ASSIGN
  init(state) := idle;
  -- only change state if active
  next(state) := case
    state = idle : { idle, entering };
    state = entering & !semaphore & active : critical;
    state = critical & active : { critical, exiting };
    state = exiting & active : idle;
    TRUE : state;
  esac;
-- Make sure each user gets a chance to go through all states.
FAIRNESS
  state = exiting;

MODULE main
VAR
  semaphore : boolean;
  -- Keep track of which user is running instead of using processes
  running : 0..1;
  proc1 : user(semaphore, next(running) = 0);
  proc2 : user(semaphore, next(running) = 1);
ASSIGN
  init(semaphore) := FALSE;
  -- If the semaphore is available (false) then the active user can go to critical
  -- and take the semaphore (true). Once the active user exits critical it also
  -- releases the semaphore (false).
  next(semaphore) := case
    proc1.state = entering & next(running) = 0 & !semaphore : TRUE;
    proc1.state = exiting & running = 0 & semaphore : FALSE;
    proc2.state = entering & next(running) = 1 & !semaphore : TRUE;
    proc2.state = exiting & running = 1 & semaphore : FALSE;
    TRUE : semaphore;
esac;

SPEC AG !(proc1.state = critical & proc2.state = critical); -- safety

SPEC AG (proc1.state = entering -> AF proc1.state = critical); -- liveness

/--
Without exiting fairness:
-- specification AG !(proc1.state = critical & proc2.state = critical)  is true
-- specification AG (proc1.state = entering -> AF proc1.state = critical)  is false
-- as demonstrated by the following execution sequence
Trace Description: CTL Counterexample
Trace Type: Counterexample
  -> State: 1.1 <-
    semaphore = FALSE
    running = 0
    proc1.state = idle
    proc2.state = idle
  -> State: 1.2 <-
    proc1.state = entering
  -> State: 1.3 <-
    running = 1
    proc2.state = entering
  -- Loop starts here
  -> State: 1.4 <-
    semaphore = TRUE
    proc2.state = critical
  -> State: 1.5 <-
    proc2.state = exiting
  -> State: 1.6 <-
    semaphore = FALSE
    proc2.state = idle
  -> State: 1.7 <-
    proc2.state = entering
  -> State: 1.8 <-
    semaphore = TRUE
    proc2.state = critical
proc2 never lets proc1 get to critical and proc1 can therefore not exiting
--/
